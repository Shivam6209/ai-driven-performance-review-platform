import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { AIReviewEditor, ReviewSection } from '../AIReviewEditor';
import { ThemeProvider, createTheme } from '@mui/material';
import userEvent from '@testing-library/user-event';
import AIReviewEditor from '../AIReviewEditor';
import { ReviewContent } from '@/services/ai.service';

const theme = createTheme();

const mockGeneratedContent: ReviewContent = {
  content: 'This is a test review content generated by AI.',
  confidence: 0.85,
  sources: [
    {
      id: 'source1',
      type: 'feedback',
      content: 'The employee has shown great progress.',
      timestamp: '2023-01-15T10:30:00Z',
      confidence: 0.9,
    },
    {
      id: 'source2',
      type: 'goal',
      content: 'Completed the project ahead of schedule.',
      timestamp: '2023-02-20T14:45:00Z',
      confidence: 0.8,
    },
  ],
};

describe('AIReviewEditor', () => {
  const mockOnSave = jest.fn();
  const mockOnRegenerateSection = jest.fn().mockImplementation(() => Promise.resolve());

  const sampleSections: ReviewSection[] = [
    {
      id: '1',
      sectionName: 'Performance Summary',
      content: 'Employee has shown excellent performance.',
      isAIGenerated: true,
      aiConfidenceScore: 0.85,
      sourceReferences: [
        {
          id: 'src1',
          type: 'Feedback',
          preview: 'Positive feedback from team members',
        },
      ],
    },
    {
      id: '2',
      sectionName: 'Areas for Improvement',
      content: 'Could improve documentation skills.',
      isAIGenerated: true,
      aiConfidenceScore: 0.75,
      sourceReferences: [
        {
          id: 'src2',
          type: 'Goal',
          preview: 'Documentation goals not fully met',
        },
      ],
    },
  ];

  const defaultProps = {
    sections: sampleSections,
    onSave: mockOnSave,
    onRegenerateSection: mockOnRegenerateSection,
    isEditable: true,
    showSources: true,
  };

  const renderComponent = (props = defaultProps) => {
    return render(
      <ThemeProvider theme={theme}>
        <AIReviewEditor {...props} />
      </ThemeProvider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders all sections with their content', () => {
    renderComponent();
    
    expect(screen.getByText('Performance Summary')).toBeInTheDocument();
    expect(screen.getByText('Employee has shown excellent performance.')).toBeInTheDocument();
    expect(screen.getByText('Areas for Improvement')).toBeInTheDocument();
    expect(screen.getByText('Could improve documentation skills.')).toBeInTheDocument();
  });

  it('shows AI-generated indicators and confidence scores', () => {
    renderComponent();
    
    const aiLabels = screen.getAllByText('AI Generated');
    expect(aiLabels).toHaveLength(2);
    
    expect(screen.getByText('85%')).toBeInTheDocument();
    expect(screen.getByText('75%')).toBeInTheDocument();
  });

  it('displays source references when showSources is true', () => {
    renderComponent();
    
    expect(screen.getByText('Sources:')).toBeInTheDocument();
    expect(screen.getByText('Feedback Reference')).toBeInTheDocument();
    expect(screen.getByText('Goal Reference')).toBeInTheDocument();
  });

  it('hides source references when showSources is false', () => {
    renderComponent({ ...defaultProps, showSources: false });
    
    expect(screen.queryByText('Sources:')).not.toBeInTheDocument();
    expect(screen.queryByText('Feedback Reference')).not.toBeInTheDocument();
  });

  it('allows editing when isEditable is true', () => {
    renderComponent();
    
    const editButtons = screen.getAllByText('Edit');
    expect(editButtons).toHaveLength(2);
    
    fireEvent.click(editButtons[0]);
    expect(screen.getByText('Save')).toBeInTheDocument();
    expect(screen.getByText('Cancel')).toBeInTheDocument();
  });

  it('disables editing when isEditable is false', () => {
    renderComponent({ ...defaultProps, isEditable: false });
    expect(screen.queryByText('Edit')).not.toBeInTheDocument();
  });

  it('handles content editing and saving', () => {
    renderComponent();
    
    // Start editing
    const editButtons = screen.getAllByText('Edit');
    fireEvent.click(editButtons[0]);
    
    // Change content
    const textarea = screen.getByDisplayValue('Employee has shown excellent performance.');
    fireEvent.change(textarea, { target: { value: 'Updated performance summary.' } });
    
    // Save changes
    fireEvent.click(screen.getByText('Save'));
    
    expect(mockOnSave).toHaveBeenCalledWith([
      { ...sampleSections[0], content: 'Updated performance summary.' },
      sampleSections[1],
    ]);
  });

  it('handles canceling edits', () => {
    renderComponent();
    
    // Start editing
    const editButtons = screen.getAllByText('Edit');
    fireEvent.click(editButtons[0]);
    
    // Change content
    const textarea = screen.getByDisplayValue('Employee has shown excellent performance.');
    fireEvent.change(textarea, { target: { value: 'Updated performance summary.' } });
    
    // Cancel changes
    fireEvent.click(screen.getByText('Cancel'));
    
    expect(mockOnSave).not.toHaveBeenCalled();
    expect(screen.getByText('Employee has shown excellent performance.')).toBeInTheDocument();
  });

  it('handles section regeneration', async () => {
    renderComponent();
    
    const regenerateButtons = screen.getAllByText('Regenerate');
    fireEvent.click(regenerateButtons[0]);
    
    await waitFor(() => {
      expect(mockOnRegenerateSection).toHaveBeenCalledWith('1');
    });
  });

  it('shows loading state during regeneration', async () => {
    mockOnRegenerateSection.mockImplementation(() => new Promise(resolve => setTimeout(resolve, 100)));
    renderComponent();
    
    const regenerateButton = screen.getAllByText('Regenerate')[0];
    fireEvent.click(regenerateButton);
    
    expect(regenerateButton).toBeDisabled();
    
    await waitFor(() => {
      expect(regenerateButton).not.toBeDisabled();
    });
  });

  it('renders generated content correctly', () => {
    render(<AIReviewEditor {...defaultProps} />);
    expect(screen.getByText('Test generated content')).toBeInTheDocument();
  });

  it('shows edit button when editable is true', () => {
    render(<AIReviewEditor {...defaultProps} />);
    expect(screen.getByRole('button')).toBeInTheDocument();
  });

  it('does not show edit button when editable is false', () => {
    render(<AIReviewEditor {...defaultProps} editable={false} />);
    expect(screen.queryByRole('button')).not.toBeInTheDocument();
  });

  it('shows confidence score when showSources is true', () => {
    render(<AIReviewEditor {...defaultProps} showSources={true} />);
    expect(screen.getByText('Confidence Score:')).toBeInTheDocument();
  });

  it('does not show confidence score when showSources is false', () => {
    render(<AIReviewEditor {...defaultProps} />);
    expect(screen.queryByText('Confidence Score:')).not.toBeInTheDocument();
  });

  it('allows editing content when edit button is clicked', async () => {
    render(<AIReviewEditor {...defaultProps} />);
    
    // Click edit button
    const editButton = screen.getByRole('button');
    await userEvent.click(editButton);

    // Check if textarea appears
    const textarea = screen.getByRole('textbox');
    expect(textarea).toBeInTheDocument();
    expect(textarea).toHaveValue('Test generated content');
  });

  it('saves edited content when save button is clicked', async () => {
    render(<AIReviewEditor {...defaultProps} />);
    
    // Start editing
    const editButton = screen.getByRole('button');
    await userEvent.click(editButton);

    // Edit content
    const textarea = screen.getByRole('textbox');
    await userEvent.clear(textarea);
    await userEvent.type(textarea, 'Updated content');

    // Save changes
    const saveButton = screen.getByRole('button', { name: /save/i });
    await userEvent.click(saveButton);

    // Check if onSave was called with new content
    expect(mockOnSave).toHaveBeenCalledWith('Updated content');
  });

  it('cancels editing and restores original content when cancel button is clicked', async () => {
    render(<AIReviewEditor {...defaultProps} />);
    
    // Start editing
    const editButton = screen.getByRole('button');
    await userEvent.click(editButton);

    // Edit content
    const textarea = screen.getByRole('textbox');
    await userEvent.clear(textarea);
    await userEvent.type(textarea, 'Updated content');

    // Cancel changes
    const cancelButton = screen.getByRole('button', { name: /cancel/i });
    await userEvent.click(cancelButton);

    // Check if original content is restored
    expect(screen.getByText('Test generated content')).toBeInTheDocument();
    expect(mockOnSave).not.toHaveBeenCalled();
  });

  it('displays different confidence score colors based on score value', () => {
    const { rerender } = render(
      <AIReviewEditor {...defaultProps} showSources={true} confidenceScore={0.9} />
    );
    const progressBar = screen.getByRole('progressbar');
    expect(progressBar).toHaveStyle({ backgroundColor: 'rgb(76, 175, 80)' }); // success.main

    rerender(
      <AIReviewEditor {...defaultProps} showSources={true} confidenceScore={0.7} />
    );
    expect(progressBar).toHaveStyle({ backgroundColor: 'rgb(255, 152, 0)' }); // warning.main

    rerender(
      <AIReviewEditor {...defaultProps} showSources={true} confidenceScore={0.5} />
    );
    expect(progressBar).toHaveStyle({ backgroundColor: 'rgb(244, 67, 54)' }); // error.main
  });

  test('renders AI-generated content correctly', () => {
    render(
      <AIReviewEditor
        generatedContent={mockGeneratedContent}
        editable={true}
        onSave={jest.fn()}
        showSources={false}
      />
    );

    expect(screen.getByText('AI-Generated Review')).toBeInTheDocument();
    expect(screen.getByText(mockGeneratedContent.content)).toBeInTheDocument();
  });

  test('allows editing when editable prop is true', async () => {
    const user = userEvent.setup();
    const mockSave = jest.fn();
    
    render(
      <AIReviewEditor
        generatedContent={mockGeneratedContent}
        editable={true}
        onSave={mockSave}
        showSources={false}
      />
    );

    // Find and click edit button
    const editButton = screen.getByRole('button');
    await user.click(editButton);

    // Verify text area appears
    const textarea = screen.getByRole('textbox');
    expect(textarea).toBeInTheDocument();
    expect(textarea).toHaveValue(mockGeneratedContent.content);

    // Edit the content
    const newContent = 'Updated review content';
    await user.clear(textarea);
    await user.type(textarea, newContent);

    // Save the changes
    const saveButton = screen.getByText('Save Changes');
    await user.click(saveButton);

    // Verify onSave was called with new content
    expect(mockSave).toHaveBeenCalledWith(newContent);
  });

  test('shows sources when showSources is true', async () => {
    const user = userEvent.setup();
    
    render(
      <AIReviewEditor
        generatedContent={mockGeneratedContent}
        editable={true}
        onSave={jest.fn()}
        showSources={true}
      />
    );

    // Find and click the show sources button
    const showSourcesButton = screen.getByText('Show Sources');
    await user.click(showSourcesButton);

    // Verify sources are displayed
    expect(screen.getByText('Sources used for this content:')).toBeInTheDocument();
    expect(screen.getByText('The employee has shown great progress.')).toBeInTheDocument();
    expect(screen.getByText('Completed the project ahead of schedule.')).toBeInTheDocument();
  });

  test('does not show edit button when editable is false', () => {
    render(
      <AIReviewEditor
        generatedContent={mockGeneratedContent}
        editable={false}
        onSave={jest.fn()}
        showSources={false}
      />
    );

    // No edit button should be present
    expect(screen.queryByRole('button', { name: /edit/i })).not.toBeInTheDocument();
  });

  test('shows loading indicator when isLoading is true', () => {
    render(
      <AIReviewEditor
        generatedContent={mockGeneratedContent}
        editable={true}
        onSave={jest.fn()}
        showSources={false}
        isLoading={true}
      />
    );

    // LinearProgress should be present
    const progressBar = document.querySelector('.MuiLinearProgress-root');
    expect(progressBar).toBeInTheDocument();
  });

  test('shows confidence indicator with correct class', () => {
    render(
      <AIReviewEditor
        generatedContent={mockGeneratedContent}
        editable={true}
        onSave={jest.fn()}
        showSources={true}
      />
    );

    // Find confidence chip
    const confidenceChip = screen.getByText(/Confidence: 85%/i);
    expect(confidenceChip).toBeInTheDocument();
    
    // With 0.85 confidence, it should have the success class
    const chipElement = confidenceChip.closest('.MuiChip-root');
    expect(chipElement).toHaveClass('MuiChip-colorSuccess');
  });
}); 